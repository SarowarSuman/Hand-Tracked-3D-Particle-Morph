<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hand Controlled Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-input { position: absolute; top: 0; left: 0; transform: scaleX(-1); opacity: 0; pointer-events: none; }
        #ui {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #00ffcc; text-shadow: 0 0 10px #00ffcc; pointer-events: none;
        }
        h1 { margin: 0; font-size: 1.5rem; text-transform: uppercase; letter-spacing: 2px; }
        p { font-size: 0.9rem; opacity: 0.8; margin-top: 5px; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 2rem; z-index: 20;
        }
        .instruction { color: #ff0055; font-weight: bold; }
    </style>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">Initializing Vision & GPU...</div>
    <div id="ui">
        <h1>Particle Morph</h1>
        <p>Current Shape: <span id="shape-name">Sphere</span></p>
        <p>• Move Hand: Attract Particles</p>
        <p>• <span class="instruction">Pinch</span> (Thumb+Index): Condense & Heat</p>
        <p>• Move Hand Right Edge: Next Shape</p>
    </div>

    <video id="video-input"></video>
    <div id="canvas-container"></div>

<script>
    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 12000;
    const PARTICLE_SIZE = 0.15;
    const INTERACTION_RADIUS = 30; // How far hand affects particles
    
    // --- GLOBALS ---
    let scene, camera, renderer, particleSystem;
    let particlesData = [];
    let currentShapeVertices = [];
    let targetShapeVertices = []; // Where particles want to go
    let time = 0;
    
    // Interaction State
    let handPosition = new THREE.Vector3(999, 999, 999); // Start off-screen
    let isPinching = false;
    let shapeIndex = 0;
    let lastShapeSwitch = 0;
    
    // Shapes Registry
    const shapes = ['Sphere', 'Heart', 'Saturn', 'Flower', 'Cube'];

    // --- INITIALIZATION ---
    function init() {
        // 1. Scene Setup
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        // 2. Particle System Construction
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const sizes = new Float32Array(PARTICLE_COUNT);

        const colorObj = new THREE.Color();

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // Initial random positions
            positions[i * 3] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 100;

            // Base Color (Cyan/Blueish)
            colorObj.setHSL(0.5 + Math.random() * 0.2, 0.8, 0.5);
            colors[i * 3] = colorObj.r;
            colors[i * 3 + 1] = colorObj.g;
            colors[i * 3 + 2] = colorObj.b;
            
            sizes[i] = PARTICLE_SIZE;

            particlesData.push({
                velocity: new THREE.Vector3(0, 0, 0),
                originalColor: { h: 0.5 + Math.random() * 0.2, s: 0.8, l: 0.5 }
            });
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // Shader Material for nice glowing dots
        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true,
            opacity: 0.8
        });

        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // Calculate initial shape
        setTargetShape('Sphere');

        // Handle Window Resize
        window.addEventListener('resize', onWindowResize, false);

        // Start Animation Loop
        animate();
    }

    // --- SHAPE GENERATORS ---
    function getSpherePoint() {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const r = 12;
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi)
        };
    }

    function getCubePoint() {
        const s = 15;
        return {
            x: (Math.random() - 0.5) * s,
            y: (Math.random() - 0.5) * s,
            z: (Math.random() - 0.5) * s
        };
    }

    function getHeartPoint() {
        // Parametric Heart
        const t = Math.random() * Math.PI * 2;
        const u = Math.random() * Math.PI * 2; // Volume fill
        // Basic 2D heart extrusion with noise
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        const z = (Math.random() - 0.5) * 5; 
        const scale = 0.8;
        return { x: x * scale, y: y * scale, z: z };
    }

    function getFlowerPoint() {
        // Phyllotaxis
        const n = 5; // petals
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.sqrt(Math.random()) * 15;
        const x = radius * Math.cos(angle * n);
        const y = radius * Math.sin(angle * n);
        const z = (Math.random() - 0.5) * (20 - radius); // Cone shape
        return { x: x, y: y, z: z };
    }

    function getSaturnPoint() {
        // 70% Planet, 30% Rings
        if (Math.random() > 0.3) {
            // Planet
            const p = getSpherePoint();
            return { x: p.x * 0.6, y: p.y * 0.6, z: p.z * 0.6 };
        } else {
            // Rings
            const angle = Math.random() * Math.PI * 2;
            const dist = 10 + Math.random() * 8;
            return {
                x: Math.cos(angle) * dist,
                y: (Math.random() - 0.5) * 0.5,
                z: Math.sin(angle) * dist
            };
        }
    }

    function setTargetShape(shapeName) {
        targetShapeVertices = [];
        document.getElementById('shape-name').innerText = shapeName;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let p;
            switch(shapeName) {
                case 'Sphere': p = getSpherePoint(); break;
                case 'Cube': p = getCubePoint(); break;
                case 'Heart': p = getHeartPoint(); break;
                case 'Flower': p = getFlowerPoint(); break;
                case 'Saturn': p = getSaturnPoint(); break;
                default: p = getSpherePoint();
            }
            targetShapeVertices.push(p);
        }
    }

    function nextShape() {
        shapeIndex = (shapeIndex + 1) % shapes.length;
        setTargetShape(shapes[shapeIndex]);
    }

    // --- ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;

        const positions = particleSystem.geometry.attributes.position.array;
        const colors = particleSystem.geometry.attributes.color.array;
        const colorObj = new THREE.Color();

        // Check for shape switching timeout (Auto-switch every 8 seconds if no manual switch)
        if (Date.now() - lastShapeSwitch > 8000) {
           // nextShape(); 
           // lastShapeSwitch = Date.now();
        }

        // Particle Logic
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i * 3;
            const iy = i * 3 + 1;
            const iz = i * 3 + 2;

            // Current Pos
            let px = positions[ix];
            let py = positions[iy];
            let pz = positions[iz];

            // Target Pos (Shape)
            const tx = targetShapeVertices[i].x;
            const ty = targetShapeVertices[i].y;
            const tz = targetShapeVertices[i].z;

            // 1. Move towards target shape (Morphing)
            // Use a spring-like force or lerp
            const morphSpeed = 0.05;
            let vx = (tx - px) * morphSpeed;
            let vy = (ty - py) * morphSpeed;
            let vz = (tz - pz) * morphSpeed;

            // 2. Hand Interaction
            // Map 2D hand pos to 3D roughly
            // Hand Z is depth from camera
            const dx = px - handPosition.x;
            const dy = py - handPosition.y;
            const dz = pz - handPosition.z;
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

            if (dist < INTERACTION_RADIUS) {
                // If Pinching: Attraction (Black Hole effect)
                // If Open: Slight Repulsion or turbulent flow around hand
                
                const force = Math.max(0, (INTERACTION_RADIUS - dist) / INTERACTION_RADIUS);
                
                if (isPinching) {
                    // Strong attraction
                    vx -= dx * force * 0.15;
                    vy -= dy * force * 0.15;
                    vz -= dz * force * 0.15;
                } else {
                    // Gentle floaty attraction/turbulence
                    vx -= dx * force * 0.02;
                    vy -= dy * force * 0.02;
                    vz -= dz * force * 0.02;
                    
                    // Add some noise
                    vx += (Math.random() - 0.5) * 0.2;
                    vy += (Math.random() - 0.5) * 0.2;
                }
            }

            // Apply Velocity
            positions[ix] += vx;
            positions[iy] += vy;
            positions[iz] += vz;

            // 3. Color Dynamics
            if (isPinching && dist < INTERACTION_RADIUS) {
                // Turn Red/Orange when pinching (Heat)
                colorObj.setHSL(0.05 + Math.random() * 0.1, 1.0, 0.6);
            } else {
                // Revert to original color slowly
                const h = particlesData[i].originalColor.h;
                const s = particlesData[i].originalColor.s;
                const l = particlesData[i].originalColor.l;
                
                // Get current color
                const curCol = new THREE.Color().fromArray(colors, ix);
                const targetCol = new THREE.Color().setHSL(h, s, l);
                
                colorObj.copy(curCol).lerp(targetCol, 0.05);
            }

            colors[ix] = colorObj.r;
            colors[iy] = colorObj.g;
            colors[iz] = colorObj.b;
        }

        particleSystem.geometry.attributes.position.needsUpdate = true;
        particleSystem.geometry.attributes.color.needsUpdate = true;

        // Gentle Scene Rotation
        particleSystem.rotation.y = time * 0.05;

        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }


    // --- COMPUTER VISION SETUP (MEDIAPIPE) ---
    
    const videoElement = document.getElementById('video-input');

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];

            // 1. Get Hand Position
            // MediaPipe Coords: x [0,1] (left-right), y [0,1] (top-bottom)
            // ThreeJS Coords: x [-W, W], y [H, -H]
            
            // Note: We flip X because webcam is mirrored usually
            const x = (1 - landmarks[9].x) * 40 - 20; // 9 is middle finger mcp (palm center-ish)
            const y = -(landmarks[9].y * 30 - 15);
            // Z estimation (landmarks[9].z is relative depth)
            const z = landmarks[9].z * 20; 

            // Smooth hand movement
            handPosition.lerp(new THREE.Vector3(x, y, z), 0.2);

            // 2. Check Pinch (Distance between Index Tip [8] and Thumb Tip [4])
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            
            // Threshold for pinch
            isPinching = pinchDist < 0.05;

            // 3. Check Gesture for Switching Shapes
            // If hand is at the far right of the screen
            if (landmarks[9].x < 0.15) { // Mirrored, so left in MP is right on screen
                if (Date.now() - lastShapeSwitch > 1500) {
                    nextShape();
                    lastShapeSwitch = Date.now();
                }
            }

        } else {
            // No hand detected - move target away
            handPosition.lerp(new THREE.Vector3(999, 999, 999), 0.1);
            isPinching = false;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });

    cameraUtils.start();

    // Init Three.js
    init();

</script>
</body>
</html>
